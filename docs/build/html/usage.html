<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Usage &mdash; tensorscout 2.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="api.html" />
    <link rel="prev" title="Welcome to tensorscout’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            tensorscout
          </a>
              <div class="version">
                2.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monte-carlo-sampling-with-multiple-processors">Monte Carlo sampling with multiple processors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallel-computation-on-sectorized-matrices-using-multiprocessing">Parallel Computation on Sectorized Matrices using Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">tensorscout</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Usage</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this heading"></a></h1>
<section id="installation">
<span id="id1"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h2>
<p>It is recommended you use voxelmap through a virtual environment. You may follow the below simple protocol to create the virtual environment, run it, and install the package there:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>virtualenv<span class="w"> </span>venv
<span class="gp">$ </span><span class="nb">source</span><span class="w"> </span>venv/bin/activate
<span class="gp gp-VirtualEnv">(.venv)</span> <span class="gp">$ </span>pip<span class="w"> </span>install<span class="w"> </span>tensorscout
</pre></div>
</div>
<p>To exit the virtual environment, simply type <code class="docutils literal notranslate"><span class="pre">deactivate</span></code>. To access it at any other time again, enter with the above <code class="docutils literal notranslate"><span class="pre">source</span></code> command.</p>
</section>
<section id="monte-carlo-sampling-with-multiple-processors">
<h2>Monte Carlo sampling with multiple processors<a class="headerlink" href="#monte-carlo-sampling-with-multiple-processors" title="Permalink to this heading"></a></h2>
<p>When performing Monte Carlo sampling at a high number, it can significantly impact computing power.
To address this, we have developed the <code class="docutils literal notranslate"><span class="pre">&#64;multicarlo</span></code> decorator, which allocates a specific number of iterations to
a defined number of available processors or cores. In our case, since we have a computer with 4 cores, we have set
the num_cores to 4. However, you can set it to as many cores as your computer or server may have available.</p>
<p>In this example, we compare the runtime performance of this multiprocessing decorator with the bare approach,
which uses a single core. We begin by importing all the required modules and defining a function that is used
in both approaches to avoid redundancy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorscout</span> <span class="k">as</span> <span class="nn">scout</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">timethis</span> <span class="kn">import</span> <span class="n">timethis</span>

<span class="k">def</span> <span class="nf">make_histograms</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="o">+</span><span class="s1">&#39;(N = 100,000)&#39;</span><span class="p">)</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<p>The operations we run on both methodologies are random sampling operations which take random numbers from a distribution.
For both methods, we set the number of samples to 100,000, which is a considerable amount.
In the following code block, we apply the <code class="docutils literal notranslate"><span class="pre">&#64;multicarlo</span></code> decorator to our random sampling function <code class="docutils literal notranslate"><span class="pre">monte_carlo_function</span></code>
and distribute the sampling iterations across four cores.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">timethis()</span></code> function is used to record the run times of both methods and print them as a terminal output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;data resampling (with @multicarlo -- 4 cores)&#39;</span>
<span class="k">with</span> <span class="n">timethis</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>

   <span class="nd">@scout</span><span class="o">.</span><span class="n">multicarlo</span><span class="p">(</span><span class="n">num_iters</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">num_cores</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
   <span class="k">def</span> <span class="nf">monte_carlo_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">simulated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">simulated_data</span>

   <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="n">results</span> <span class="o">=</span> <span class="n">monte_carlo_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
   <span class="n">make_histograms</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
</pre></div>
</div>
<p>The following code block executes the same tasks as the previous block, but using a bare approach,
meaning that it uses a single core to perform all 100,000 random samples.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;data resampling (bare)&#39;</span>
<span class="k">with</span> <span class="n">timethis</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">monte_carlo_function_bare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">simulated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">simulated_data</span>

   <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">monte_carlo_function_bare</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)]</span>
   <span class="n">make_histograms</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous three code blocks is displayed below.</p>
<p><a class="reference internal" href="_images/multicarlo.png"><img alt="Alternative text" src="_images/multicarlo.png" style="width: 320px;" /></a> <a class="reference internal" href="_images/bare_multicarlo.png"><img alt="Alternative text" src="_images/bare_multicarlo.png" style="width: 320px;" /></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">OUT</span><span class="p">]</span>
<span class="go">monte carlo resampling (with @multicarlo -- 4 cores): 2.812 seconds</span>
<span class="go">monte carlo resampling (bare): 4.328 seconds</span>
</pre></div>
</div>
<p>Both approaches produce a similar random sampling distribution outcome,
but the <code class="docutils literal notranslate"><span class="pre">&#64;multicarlo</span></code> decorated function that uses multiprocessing on 4 cores shows around 50% better runtime performance.</p>
</section>
<section id="parallel-computation-on-sectorized-matrices-using-multiprocessing">
<h2>Parallel Computation on Sectorized Matrices using Multiprocessing<a class="headerlink" href="#parallel-computation-on-sectorized-matrices-using-multiprocessing" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/andrewrgarcia/voxelmap"><img alt="Alternative text" src="_images/cakerun_concept.png" style="width: 300px;" /></a> <a class="reference external" href="https://github.com/andrewrgarcia/voxelmap"><img alt="Alternative text" src="_images/coik.jpg" style="width: 300px;" /></a></p>
<p>The question of whether it’s faster to eat a cake alone or have 100 people cut a slice and eat their portions until
it’s gone highlights the main concept behind the cakerun decorator.
Essentially, the decorator partitions an array into a specified number of equally-sized sectors and performs
the same task on all sectors in parallel.</p>
<p>In this example, we set the number of cores to 4 and compare the performance of using multiprocessing versus
using a single core. Before proceeding, we import all necessary modules and define the draw function which is
used in both approaches to avoid redundancy. Additionally, we define the initial matrix, which is a 252 x 252 matrix of 1s,
that will be operated on by both methodologies.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorscout</span> <span class="k">as</span> <span class="nn">scout</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">timethis</span> <span class="kn">import</span> <span class="n">timethis</span>

<span class="n">num_iters</span> <span class="o">=</span> <span class="mi">40000</span>

<span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> -- $N_{{perforated}}$ = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">result</span><span class="p">)))</span>
   <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>


<span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">252</span><span class="p">,</span><span class="mi">252</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;initial canvas&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/black_canvas.png"><img alt="Alternative text" src="_images/black_canvas.png" style="width: 320px;" /></a>
<p>In this example, the initial matrix is composed entirely of 1s and will appear as a single color when drawn.
The purpose of this code is to apply an operation called “perforation” to the matrix. At each iteration,
a random x-y coordinate is selected and the value at that location is set to 0.</p>
<p>The first case demonstrates the use of the <code class="docutils literal notranslate"><span class="pre">&#64;cakerun</span></code> decorator to split the matrix into sectors and apply
the perforate function to each sector. The former code block specifies 40,000 perforating iterations, which for the case
of this aprroach has them evenly distributed across the 4 sectors, resulting in 10,000 iterations per sector, ocurring simultaneously.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;cakerun MP (4 cores)&#39;</span>
<span class="k">with</span> <span class="n">timethis</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">)):</span>

   <span class="n">cores</span> <span class="o">=</span> <span class="mi">4</span>
   <span class="nd">@scout</span><span class="o">.</span><span class="n">cakerun</span><span class="p">(</span><span class="n">num_cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">L_sectors</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
   <span class="k">def</span> <span class="nf">perforate</span><span class="p">(</span><span class="n">sector</span><span class="p">):</span>

      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iters</span> <span class="o">//</span> <span class="n">cores</span><span class="p">):</span>
            <span class="n">cds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">sector</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sector</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">cds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])]</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">return</span> <span class="n">sector</span>

   <span class="n">result</span> <span class="o">=</span> <span class="n">perforate</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
   <span class="n">draw</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>In the next code block, the perforating operation is applied for 40,000 iterations using a bare approach with a single processor.
Hence, there is no task split involved.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;single core&#39;</span>
<span class="k">with</span> <span class="n">timethis</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">)):</span>

   <span class="k">def</span> <span class="nf">perforate_bare</span><span class="p">(</span><span class="n">sector</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iters</span><span class="p">):</span>
            <span class="n">cds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">sector</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sector</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">cds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])]</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">return</span> <span class="n">sector</span>


   <span class="n">result</span> <span class="o">=</span> <span class="n">perforate_bare</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
   <span class="n">draw</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The following are graphical and runtime comparisons of both methods:</p>
<p><a class="reference internal" href="_images/cakerun.png"><img alt="Alternative text" src="_images/cakerun.png" style="width: 320px;" /></a> <a class="reference internal" href="_images/bare_cakerun.png"><img alt="Alternative text" src="_images/bare_cakerun.png" style="width: 320px;" /></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">OUT</span><span class="p">]</span>
<span class="go">cakerun MP (4 cores): 2.968 seconds</span>
<span class="go">single core: 25.868 seconds</span>
</pre></div>
</div>
<p>It is apparent that both approaches yield a similar outcome and have
the same number of perforations. However, the <code class="docutils literal notranslate"><span class="pre">&#64;cakerun</span></code> decorated function, which uses four
cores simultaneously, has a runtime that is 8-9 times faster than the bare approach.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to tensorscout’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Andrew Garcia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>